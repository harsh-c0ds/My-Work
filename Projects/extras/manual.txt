{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hybrid MATLAB-Python Deconvolution Pipeline Manual\n",
    "---\n",
    "This notebook serves as both a user manual and an execution environment for the image restoration pipeline. It integrates optical physics simulation (MATLAB) with advanced recovery algorithms (Python).\n",
    "\n",
    "## 1. Pipeline Overview\n",
    "The imaging system simulates a lens with **Aberrations** (Defocus and Astigmatism). The workflow is divided into three stages:\n",
    "1. **PSF Simulation (MATLAB):** Calculation of the Point Spread Function based on physical parameters.\n",
    "2. **Forward Model:** Application of the PSF and Poisson noise to a ground truth image.\n",
    "3. **Deconvolution (Python):** Recovery of the image using Richardson-Lucy and MAP-TV optimization."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Pre-requisites (MATLAB)\n",
    "Before running this notebook, you must generate your optical data using the provided MATLAB scripts. \n",
    "\n",
    "### Step A: Generate PSF\n",
    "Run `psf_sim_aberr.m`. This computes the linear PSF using the following relation:\n",
    "$$PSF = | \\mathcal{F} \\{ Pupil \\cdot e^{i W} \\} |^2$$\n",
    "Where $W$ represents the aberration phase. This script saves `psf_linear.mat`.\n",
    "\n",
    "### Step B: Generate Noisy Input\n",
    "Run `forward_model.m`. This applies the PSF to a phantom and adds **Poisson Noise**, which is the primary noise model for optical systems. This script saves `noisy.png`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 3. Python Execution Environment\n",
    "Run the cells below to perform the reconstruction. This code is modularized from your `main_pipeline.py` script."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from skimage import io\n",
    "from skimage.restoration import richardson_lucy, denoise_tv_chambolle\n",
    "from skimage.metrics import mean_squared_error, structural_similarity\n",
    "from scipy.signal import fftconvolve\n",
    "\n",
    "# Import custom utilities\n",
    "from utils_forward import load_psf, normalize\n",
    "\n",
    "# Configuration\n",
    "FIGDIR = r\"D:\\Projects\\results\\figures\"\n",
    "PSF_PATH = os.path.join(FIGDIR, 'psf_linear.mat')\n",
    "NOISY_PATH = os.path.join(FIGDIR, 'noisy.png')\n",
    "GT_PATH = os.path.join(FIGDIR, 'ground_truth.png')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### MAP-TV Algorithm\n",
    "This function implements a Maximum Likelihood solver with a Total Variation (TV) proximal step to suppress noise while preserving edges."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def run_map_tv(y, PSF, niter=50, alpha=0.15, lam=0.02):\n",
    "    PSF_flip = PSF[::-1, ::-1] # Adjoint PSF\n",
    "    x = y.copy()\n",
    "    for k in range(niter):\n",
    "        # Forward projection\n",
    "        Hx = fftconvolve(x, PSF, mode='same') + 1e-8\n",
    "        # Poisson gradient\n",
    "        grad = fftconvolve(1 - y / Hx, PSF_flip, mode='same')\n",
    "        x -= alpha * grad\n",
    "        x = np.clip(x, 0, None)\n",
    "        # TV Denoising step\n",
    "        x = denoise_tv_chambolle(x, weight=lam, channel_axis=None)\n",
    "    return normalize(x)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Execution and Analysis\n",
    "The following cell loads your MATLAB outputs, runs the deconvolution, and calculates performance metrics (RMSE and SSIM)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 1. Load Data\n",
    "PSF = load_psf(PSF_PATH)\n",
    "y = io.imread(NOISY_PATH, as_gray=True) / 255.0\n",
    "gt = io.imread(GT_PATH, as_gray=True) / 255.0\n",
    "\n",
    "# 2. Run Richardson-Lucy (Baseline)\n",
    "rl_recon = normalize(richardson_lucy(y, PSF, num_iter=12, clip=True))\n",
    "\n",
    "# 3. Run MAP-TV (Advanced)\n",
    "tv_recon = run_map_tv(y, PSF)\n",
    "\n",
    "# 4. Metrics\n",
    "ssim_rl = structural_similarity(gt, rl_recon, data_range=1.0)\n",
    "ssim_tv = structural_similarity(gt, tv_recon, data_range=1.0)\n",
    "\n",
    "# 5. Visualization\n",
    "plt.figure(figsize=(15, 5))\n",
    "plt.subplot(131); plt.imshow(y, cmap='gray'); plt.title('Noisy Input (MATLAB)')\n",
    "plt.subplot(132); plt.imshow(rl_recon, cmap='gray'); plt.title(f'RL Recon (SSIM: {ssim_rl:.3f})')\n",
    "plt.subplot(133); plt.imshow(tv_recon, cmap='gray'); plt.title(f'MAP-TV Recon (SSIM: {ssim_tv:.3f})')\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}